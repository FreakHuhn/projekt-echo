# ğŸ§  Refactoring-Guide fÃ¼r logic.py: Modularisierung & Mini-Router

## ğŸ¯ Ziel
Die Datei `logic.py` ist zu groÃŸ und Ã¼bernimmt zu viele Verantwortlichkeiten. Ziel dieses Refactorings ist es, die Datei in modulare Einzelteile zu zerlegen und eine zentrale Routing-Stelle (`handle_command`) einzufÃ¼hren.

---

## ğŸ§© Modulstruktur

Wir schlagen folgende Struktur unter `/features/` vor:

```
features/
â”‚
â”œâ”€â”€ quiz.py           # Alle Quiz-bezogenen Funktionen (!gamequiz, !antwort, Bewertung, Eastereggs)
â”œâ”€â”€ invite.py         # Parsing und Verarbeitung von !invite und !silentinvite
â”œâ”€â”€ echolive.py       # Kontextbezogene GPT-Kommandos wie !echolive
â”œâ”€â”€ judge.py          # Kontextanalyse mit TonalitÃ¤t (â€Zynischer Richterâ€œ)
```

---

## ğŸ” Mini-Router Konzept

### Datei: logic.py

Zentrale `handle_command()`-Funktion leitet eingehende Befehle weiter â€“ an die jeweils zustÃ¤ndigen Feature-Handler.

**Beispiel:**

```python
from features.quiz import handle_quiz_command
from features.invite import handle_invite_command
from features.echolive import handle_echolive_command

def handle_command(command, user_memory, username):
    if command.startswith("!gamequiz") or command.startswith("!antwort"):
        return handle_quiz_command(command, user_memory, username)

    elif command.startswith("!invite") or command.startswith("!silentinvite"):
        return handle_invite_command(command, user_memory, username)

    elif command.startswith("!echolive"):
        return handle_echolive_command(command, user_memory, username)

    # Standard-Commands (bleiben erstmal hier)
    elif command == "!help":
        return "ğŸ“– Hilfe..."
    
    elif command == "!status":
        # evtl. spÃ¤ter in features/status.py
        ...

    return "Unbekannter Befehl. Gib `!help` ein fÃ¼r alle Befehle."
```

---

## ğŸ“¦ Feature-Dateien

### features/quiz.py

```python
def handle_quiz_command(command, user_memory, username):
    if command.startswith("!gamequiz"):
        # bestehende gamequiz-Logik hierher verschieben
        ...
    elif command.startswith("!antwort"):
        # bestehende Antwort-Logik hierher verschieben
        ...
    return "Unbekannter Quiz-Befehl"
```

---

### features/invite.py

```python
def handle_invite_command(command, user_memory, username):
    # parse_invite_command() aufrufen
    # session["last_skill"] setzen
    ...
    return "Einladungs-Logik lÃ¤uft"
```

---

### features/echolive.py

```python
def handle_echolive_command(command, user_memory, username):
    return "__ECHOLIVE__"
```

Diese Flag-RÃ¼ckgabe wird in `echo_bot.py` abgefangen.

---

## ğŸ”§ Weitere Ã„nderungen

### 1. `process_input()` bleibt in logic.py
- LÃ¤dt Speicher
- Loggt Nachricht
- Ruft `handle_command()` auf
- Speichert Ergebnis

### 2. Importpfade anpassen
- `from features.quiz import handle_quiz_command` usw.

### 3. Feature-Files: mit Kommentaren strukturieren
- Jede Funktion sauber kommentieren
- Testbare Einzelfunktionen ermÃ¶glichen

---

## âœ… Vorteile

- Saubere Trennung der Verantwortlichkeiten
- Leicht testbar
- Leicht erweiterbar (!judge, !profil, !moodcheck, ...)
- EinstiegshÃ¼rde fÃ¼r neue Entwickler oder Helfer niedriger